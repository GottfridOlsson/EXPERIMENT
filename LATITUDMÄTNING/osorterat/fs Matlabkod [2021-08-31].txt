%% HORIZON-SEXTANT-SUN ANGLE OVER TIME WITH AN 'OCTANT' %%
%-------------------------------------------------------%%
%      Author: GOTTFRID OLSSON
%     Created: 2021-08-24, 11:58
%     Updated: 2021-08-31, 20:52
%       About: Data processing of latitude measurements 
%              done with a home-made 'octant' or sextant. 
%              Measured angle is between horizon and Sun.
%               1. From angles the same day, find angle
%                  during solar noon.
%               2. Plot noon-angle over time (months).
%               3. Curve-fit a sinus/cosinus. 
%              alpha = angle measured w octant @solarnoon
%%------------------------------------------------------%%
%%
clc, clf


% READ CSV-FILE %

lastUpdated   = "2021-08-31";
T             = readtable('latitudeMeasurements['+lastUpdated+'].csv');
Date          = T.Date(1:end);
TimeOfDay     = T.TimeOfDay(1:end);
MeasuredAngle = T.MeasuredAngle(1:end);
DayOfYear     = T.DayOfYear(1:end);
Correction    = T.Correction(1:end); %do this calculation yourself
Latitude      = T.CalculatedLatitude(1:end); %do this calculation yourself

showAlphaForEachDay = false; %True if you want to see

% CONSTANTS %
allDaysOfYear = (1:365);





% 1. FIND NOON-ANGLE FOR EACH DAY %

uniqueDates = unique(Date);
uniqueDayOfYear = unique(DayOfYear);

MeasurementOfDate = @(date) T(T.Date == date,:);
%MeasurementOfDate('2021-02-27') %works!
LatitudeOfDate = @(date) MeasurementOfDate(date).MeasuredAngle;
%LatitudeOfDate('2021-02-27') %works!
TimeOfDate = @(date) MeasurementOfDate(date).TimeOfDay;
%TimeOfDate('2021-02-27') %works!

% naive approach: take minimal angle (sun highets in sky) for each date
%
NumUniqueDates = numel(uniqueDates);
naiveNoonAngle = zeros(NumUniqueDates,1);
minIndex = zeros(NumUniqueDates,1);
accMinIndexes = zeros(NumUniqueDates,1);

for index = 1:NumUniqueDates
    date_i = uniqueDates(index);
    [naiveNoonAngle(index), minIndex] = min(LatitudeOfDate(date_i));
    
    %This part is a mess, but it works - so don't touch it! //2021-08-24
    if index == 1
        accMinIndexes(index) = minIndex;
    else
        accMinIndexes(index) = minIndex + accMinIndexes(index)+ accMinIndexes(index-1);
        if index ~= NumUniqueDates
            %we need to add the number of measurements left on each day
            %to the NEXT accMinIndex, otherwise we skip elements in Table
            correction = numel(LatitudeOfDate(date_i)) - minIndex;
            accMinIndexes(index+1) = correction;
        end
    end
end

naiveNoonAngleTable = T(accMinIndexes,:);


% more sophisticated approach: do curvefit with cosine and min/max
%

% convert times of format 'hh:mm' to number of minutes

if showAlphaForEachDay == true
    for index = 1:NumUniqueDates
       clf
       date_i = uniqueDates(index);
       timeArray  = TimeOfDate(date_i);
       alphaArray = LatitudeOfDate(date_i);
       NumTime = numel(timeArray);

       minutes = zeros(1,NumTime);
       alpha = zeros(1,NumTime);
       for k = 1:NumTime
           timeString_k = string(timeArray(k,1));
           minutes_k = getMinutesFromTimeString(timeString_k);
           minutes(k) = minutes_k;
           alpha_k = alphaArray(k,1);
           alpha(k) = alpha_k;
           plot(minutes_k, alpha_k, 'ro', 'LineWidth', 2); hold on;
           set(gca,'Ticklabelinterpreter','latex','Fontsize',14)
           title(string(date_i),...
                'Interpreter','latex','Fontsize',19)
           xlabel('Minute of day (12:00 = 720)',...
                'interpreter','latex','Fontsize',16)
           ylabel('Measured $\alpha$ (deg)',...
                'interpreter','latex','Fontsize',16)
       end
       naiveNoonAngle = min(alpha);
       naiveNoonAngleTime = minutes(alpha == naiveNoonAngle);
       plot(naiveNoonAngleTime, naiveNoonAngle, 'bs', 'MarkerSize', 10,...
           'LineWidth', 3)

       pause
       clc
       if index ~= NumUniqueDates
           fprintf('Press a key to move on (%d left)\n',NumUniqueDates-index)
       end
    end
end



% 2. PLOT NOON-ANGLE OVER TIME %

plot(uniqueDayOfYear, naiveNoonAngle, 'ro', 'LineWidth', 1.5)
set(gca,'Ticklabelinterpreter','latex','Fontsize',14)
title('title',...
    'Interpreter','latex','Fontsize',19)
xlabel('Day of year (Jan1 = 0)',...
    'interpreter','latex','Fontsize',16)
ylabel('Measured $\alpha$ (deg)',...
    'interpreter','latex','Fontsize',16)
    




% CALCULATE DAY OF YEAR FROM DATES % (Jan1=0, Jan2=1, ...)

DayOfYear2021 = @(date) datenum(date) - datenum('2021-01-01');
%DayOfYear2021('2021-12-01') %works!

calculatedDayOfYear = zeros(NumUniqueDates,1);
for index = 1:NumUniqueDates
    date_i = uniqueDates(index);
   calculatedDayOfYear(index) = DayOfYear2021(date_i);
end    
%deltaDayOfYear = calculatedDayOfYear - uniqueDayOfYear; %to check


% CALCULATED CORRECTION %

CorrectionOfDay = @(dayOfYear) -23.5*cos(2*pi*(dayOfYear+10)/365);
calculatedCorrection = round(CorrectionOfDay(DayOfYear2021(uniqueDates)),2);
CalculatedLatitude = naiveNoonAngle + calculatedCorrection;

%plot(uniqueDayOfYear, CalculatedLatitude, 'ro', 'Linewidth', 1.5)





clf
% 3. CURVE-FIT COSINUS %
day = uniqueDayOfYear;
alpha = naiveNoonAngle;
errorAlpha = 1*ones(size(alpha)); %well w.in uncert., could argue for +-0.5 
%actualF = @(day) 57.7 + 23.5*cos(2*pi*(day+10)/365); #?or guessed F (?)

f = @(b, day) b(1) + b(2)*cos(b(3)*day+b(4)); %fitting function
b0 = [60, 23.5, 2*pi/360, 0]; %initial guess 

opts = statset('maxIter', 500, 'TolFun', 1e-5); %fit options
mdl = fitnlm(day, alpha, f, b0, 'Options', opts); %the fit
coeff = mdl.Coefficients.Estimate; %the fit coeff b

errorbar(day, alpha, errorAlpha, 'ro', 'LineWidth', 1.3); hold on;
 %plot(day, alpha, 'ro', 'LineWidth', 1.3); hold on;
plot(allDaysOfYear ,f(coeff,allDaysOfYear), 'b--', 'LineWidth', 1.5)
%plot(allDaysOfYear, actualF(allDaysOfYear), 'k--', 'LineWidth', 1.5)
set(gca,'Ticklabelinterpreter','latex','Fontsize',14)
titleCurve = sprintf('f(x) = %.3f + %.3f* $cos$(%.3fx + %.3f)',...
    coeff(1),coeff(2),coeff(3),coeff(4));
title('Fitted latitude curve: $'+string(titleCurve)+'$',...
    'Interpreter','latex','Fontsize',19)
xlabel('Day $x$ of year 2021 (Jan1 = 0)',...
    'interpreter','latex','Fontsize',16)
ylabel('Latitude (deg)',...
    'interpreter','latex','Fontsize',16)
legend('Datapoints ($\pm 1$ deg)', 'Fitted curve $f(x)$','Actual curve',...
    'Location','Best','Interpreter','latex','Fontsize',14)
axis([0 370 20 90]) %should do one graph with latutide [0 90]

%OBS! coeff(1) and coeff(2) are in degrees, since thay are outside cos() 
%     coeff(3) and coeff(4) are in radians, since they are inside cos()

% NOTE! f(x) = A + B*cos(C*x+D) means:
%   A: mean latitude (e.g. when no correction is needed)
%   B: should be ~23.5, Earths axial tilt (correction amplitude)
%   C: ~2*pi/360 = 0.016 since it compensates for each day (d)
%   D: ~2*pi*10/365 = 0.164 acc. to the model in How To Invent Everything
% Nice to see how it all makes sense! //2021-08-25, 15:04

%%
function totalMinutes  = getMinutesFromTimeString(timeString)
    % timeString in format 'hh:mm' [24h]
    % convert times of format 'hh:mm' to number of minutes
    getSubstring = @(string,i,n) extractBetween(string,i,n);
    hourString = getSubstring(timeString,1,2);
    minuteString = getSubstring(timeString,4,5);
    
    HourStringToDigitMinute = @(hourString) str2num(hourString)*60;
    MinuteStringToDigitMinute = @(minuteString) str2num(minuteString);
    
    hourMinutes = HourStringToDigitMinute(hourString);
    minutes = MinuteStringToDigitMinute(minuteString);
    
    totalMinutes = hourMinutes + minutes;
end

% EOF %